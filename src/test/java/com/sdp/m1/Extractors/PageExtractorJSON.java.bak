package com.sdp.m1.Extractors;

import java.io.FileWriter;
import java.time.Duration;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.openqa.selenium.By;
import org.openqa.selenium.Dimension;
import org.openqa.selenium.Point;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.sdp.m1.Runner.TestConfigs;

public class PageExtractorJSON {

    static class Component {
        String type; // form, navbar, etc.
        String tag; // div, form, input, button...
        String text; // visible text
        String id;
        String classes;
        String selector;
        Map<String, Integer> boundingBox;

        List<Map<String, String>> actions = new ArrayList<>(); // each action = button/link with attrs
        List<Map<String, String>> fields = new ArrayList<>(); // each field = input/select with attrs
    }

    public static void main(String[] args) throws Exception {
        WebDriver driver = new ChromeDriver();
        // driver options: headless
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(Integer.parseInt(TestConfigs.DELAY)));
        driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(Integer.parseInt(TestConfigs.DELAY)));

        String url = "https://www.google.com";
        driver.get(url); // your local test app
        String fileName = String.format("page_components_%s_%s.json", url.hashCode(), System.currentTimeMillis());

        String pageSource = driver.getPageSource();
        Document doc = Jsoup.parse(pageSource);

        List<Component> components = new ArrayList<>();

        // Extract candidate components: forms, nav, header, aside, main, footer
        extractByTag(doc, driver, "form", "form", components);
        extractByTag(doc, driver, "nav", "navbar", components);
        extractByTag(doc, driver, "header", "header", components);
        extractByTag(doc, driver, "aside", "sidebar", components);
        extractByTag(doc, driver, "main", "main", components);
        extractByTag(doc, driver, "footer", "footer", components);

        // Fallback: large DIVs (for dashboards or grid layouts)
        extractByTag(doc, driver, "div", "section", components);

        // Save JSON
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        try (FileWriter fw = new FileWriter(fileName)) {
            gson.toJson(components, fw);
        } catch (Exception e) {
            System.out.println(String.format("Failed to save JSON: %s", e.getMessage()));
        }

        System.out.println(String.format("Extracted %d components -> %s", components.size(), fileName));
        driver.quit();
    }

    private static void extractByTag(Document doc, WebDriver driver, String tag, String type,
            List<Component> components) {

        Elements elements = doc.select(tag);

        for (Element el : elements) {
            try {
                // Find same element in Selenium DOM for bounding box
                WebElement we = null;
                
                if (el.id().length() > 0) {
                    we = driver.findElement(By.id(el.id()));
                } else {
                    we = driver.findElement(By.xpath(getXPath(el)));
                }

                Component c = new Component();
                c.type = type;
                c.tag = el.tagName();
                c.text = el.ownText();
                c.id = el.id();
                c.classes = el.className();
                c.selector = buildSelector(el);

                // Check if similar component already exists
                boolean duplicate = components.stream().anyMatch(existing -> existing.fields.containsAll(c.fields) &&
                        existing.actions.containsAll(c.actions));
                if (duplicate) {
                    continue; // skip duplicates
                }
                // Bounding box
                Map<String, Integer> box = new HashMap<>();
                Point p = we.getLocation();
                Dimension d = we.getSize();
                box.put("x", p.getX());
                box.put("y", p.getY());
                box.put("width", d.getWidth());
                box.put("height", d.getHeight());
                c.boundingBox = box;

                // Extract actions (buttons, links inside)
                Elements buttons = el.select("button, input[type=submit], a");
                for (Element b : buttons) {
                    c.actions.add(buildSelector(b));
                }

                // Extract fields (inputs inside)
                Elements inputs = el
                        .select("input[type=text], input[type=password], input[type=email], textarea, select");
                for (Element f : inputs) {
                    c.fields.add(buildSelector(f));
                }

                components.add(c);

            } catch (Exception ignored) {
                System.out.println(String.format("Failed to extract component: %s", ignored.getMessage()));
                // Some elements may not be found in Selenium DOM
            }
        }
    }

    // Build CSS selector for an element
    private static String buildSelector(Element el) {
        if (!el.id().isEmpty()) {
            return "#" + el.id();
        } else if (!el.className().isEmpty()) {
            return el.tagName() + "." + el.className().replace(" ", ".");
        } else {
            return el.tagName();
        }
    }

    // Simple XPath builder for fallback
    private static String getXPath(Element el) {
        List<String> path = new ArrayList<>();
        Element current = el;
        while (current != null && !current.tagName().equals("html")) {
            int index = 1;
            Element sibling = current.previousElementSibling();
            while (sibling != null) {
                if (sibling.tagName().equals(current.tagName()))
                    index++;
                sibling = sibling.previousElementSibling();
            }
            path.add(0, "/" + current.tagName() + "[" + index + "]");
            current = current.parent();
        }
        return "/html" + String.join("", path);
    }
}
